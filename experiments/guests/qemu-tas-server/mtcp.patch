diff -ur mtcp.old/dpdk/lib/librte_mempool/rte_mempool.c mtcp/dpdk/lib/librte_mempool/rte_mempool.c
--- mtcp.old/dpdk/lib/librte_mempool/rte_mempool.c	2020-09-08 21:17:34.052248962 +0200
+++ mtcp/dpdk/lib/librte_mempool/rte_mempool.c	2020-09-08 23:41:38.374992953 +0200
@@ -916,6 +916,8 @@
 
 	mempool_list = RTE_TAILQ_CAST(rte_mempool_tailq.head, rte_mempool_list);
 
+        fprintf(stderr, "rte_mempool_create_empty: tart\n");
+
 	/* asked cache too big */
 	if (cache_size > RTE_MEMPOOL_CACHE_MAX_SIZE ||
 	    CALC_CACHE_FLUSHTHRESH(cache_size) > n) {
@@ -933,6 +935,7 @@
 		return NULL;
 	}
 
+        fprintf(stderr, "rte_mempool_create_empty: calculated\n");
 	rte_rwlock_write_lock(RTE_EAL_MEMPOOL_RWLOCK);
 
 	/*
@@ -954,6 +957,8 @@
 	mempool_size += private_data_size;
 	mempool_size = RTE_ALIGN_CEIL(mempool_size, RTE_MEMPOOL_ALIGN);
 
+        fprintf(stderr, "rte_mempool_create_empty: size=%zu\n", mempool_size);
+
 	ret = snprintf(mz_name, sizeof(mz_name), RTE_MEMPOOL_MZ_FORMAT, name);
 	if (ret < 0 || ret >= (int)sizeof(mz_name)) {
 		rte_errno = ENAMETOOLONG;
@@ -961,8 +966,11 @@
 	}
 
 	mz = rte_memzone_reserve(mz_name, mempool_size, socket_id, mz_flags);
-	if (mz == NULL)
+	if (mz == NULL) {
+            fprintf(stderr, "rte_mempool_create_empty: reserve failed\n");
+		RTE_LOG(ERR, MEMPOOL, "memzone reserve failed %zu\n", mempool_size);
 		goto exit_unlock;
+        }
 
 	/* init the mempool structure */
 	mp = mz->addr;
@@ -972,6 +980,7 @@
 		rte_errno = ENAMETOOLONG;
 		goto exit_unlock;
 	}
+            fprintf(stderr, "rte_mempool_create_empty: init done\n");
 	mp->mz = mz;
 	mp->size = n;
 	mp->flags = flags;
@@ -1028,6 +1037,7 @@
 
 	mp = rte_mempool_create_empty(name, n, elt_size, cache_size,
 		private_data_size, socket_id, flags);
+        fprintf(stderr, "rte_mempool_create_empty=%p\n", mp);
 	if (mp == NULL)
 		return NULL;
 
@@ -1044,16 +1054,20 @@
 	else
 		ret = rte_mempool_set_ops_byname(mp, "ring_mp_mc", NULL);
 
+        fprintf(stderr, "rte_mempool_create: ops byname=%d\n", ret);
 	if (ret)
 		goto fail;
 
+        fprintf(stderr, "rte_mempool_create: before init\n");
 	/* call the mempool priv initializer */
 	if (mp_init)
 		mp_init(mp, mp_init_arg);
 
+        fprintf(stderr, "rte_mempool_create: before populate\n");
 	if (rte_mempool_populate_default(mp) < 0)
 		goto fail;
 
+        fprintf(stderr, "rte_mempool_create: before objinit\n");
 	/* call the object initializers */
 	if (obj_init)
 		rte_mempool_obj_iter(mp, obj_init, obj_init_arg);
diff -ur mtcp.old/dpdk/lib/librte_mempool/rte_mempool_ops.c mtcp/dpdk/lib/librte_mempool/rte_mempool_ops.c
--- mtcp.old/dpdk/lib/librte_mempool/rte_mempool_ops.c	2020-09-08 21:17:34.052248962 +0200
+++ mtcp/dpdk/lib/librte_mempool/rte_mempool_ops.c	2020-09-08 23:55:00.777498002 +0200
@@ -23,6 +23,7 @@
 	struct rte_mempool_ops *ops;
 	int16_t ops_index;
 
+        fprintf(stderr, "rte_mempool_register_ops: h->name=(%s)\n", h->name);
 	rte_spinlock_lock(&rte_mempool_ops_table.sl);
 
 	if (rte_mempool_ops_table.num_ops >=
@@ -30,6 +31,7 @@
 		rte_spinlock_unlock(&rte_mempool_ops_table.sl);
 		RTE_LOG(ERR, MEMPOOL,
 			"Maximum number of mempool ops structs exceeded\n");
+                fprintf(stderr, "rte_mempool_register_ops: (nospace)\n");
 		return -ENOSPC;
 	}
 
@@ -38,6 +40,7 @@
 		rte_spinlock_unlock(&rte_mempool_ops_table.sl);
 		RTE_LOG(ERR, MEMPOOL,
 			"Missing callback while registering mempool ops\n");
+                fprintf(stderr, "rte_mempool_register_ops: (invalid)\n");
 		return -EINVAL;
 	}
 
@@ -45,6 +48,7 @@
 		rte_spinlock_unlock(&rte_mempool_ops_table.sl);
 		RTE_LOG(DEBUG, EAL, "%s(): mempool_ops <%s>: name too long\n",
 				__func__, h->name);
+                fprintf(stderr, "rte_mempool_register_ops: (nametoolong)\n");
 		rte_errno = EEXIST;
 		return -EEXIST;
 	}
@@ -159,8 +163,10 @@
 	unsigned i;
 
 	/* too late, the mempool is already populated. */
-	if (mp->flags & MEMPOOL_F_POOL_CREATED)
+	if (mp->flags & MEMPOOL_F_POOL_CREATED) {
+                fprintf(stderr, "rte_mempool_set_ops_byname: already created\n");
 		return -EEXIST;
+        }
 
 	for (i = 0; i < rte_mempool_ops_table.num_ops; i++) {
 		if (!strcmp(name,
@@ -170,8 +176,10 @@
 		}
 	}
 
-	if (ops == NULL)
+	if (ops == NULL) {
+                fprintf(stderr, "rte_mempool_set_ops_byname: not found (%s)\n", name);
 		return -EINVAL;
+        }
 
 	mp->ops_index = i;
 	mp->pool_config = pool_config;
Binary files mtcp.old/.git/index and mtcp/.git/index differ
Binary files mtcp.old/.git/modules/dpdk/index and mtcp/.git/modules/dpdk/index differ
Binary files mtcp.old/.git/modules/mtcp/src/libccp/index and mtcp/.git/modules/mtcp/src/libccp/index differ
diff -ur mtcp.old/mtcp/src/io_module.c mtcp/mtcp/src/io_module.c
--- mtcp.old/mtcp/src/io_module.c	2020-09-08 21:18:23.463852529 +0200
+++ mtcp/mtcp/src/io_module.c	2020-09-09 14:58:50.360193608 +0200
@@ -303,12 +303,14 @@
 				       RTE_CACHE_LINE_SIZE);
 		
 		/* initialize the rte env, what a waste of implementation effort! */
-		int argc = 6;//8;
+		int argc = 8;//8;
 		char *argv[RTE_ARGC_MAX] = {"",
 					    "-c",
 					    cpumaskbuf,
 					    "-n",
 					    mem_channels,
+                                            "--log-level",
+                                            "*:debug",
 #if 0
 					    "--socket-mem",
 					    socket_mem_str,
